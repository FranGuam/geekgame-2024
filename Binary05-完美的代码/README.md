### 题面

小E为某开源软件贡献代码十年之久，终于成为了该软件的核心开发者。可是，小E并不想为爱发电，他决定向该软件中注入后门，以便盗取神秘货币发大财。

过去了这么多年，小E后知后觉地发现这款软件的核心代码都已经用Rust重写了，想要同往常一样在C/C++代码中假装无意插入一个内存安全漏洞的好日子一去不复返。小E意识到通过常规手段悄悄插入一个足够隐秘的后门似乎并没有那么容易。于是，他编写了一段 **完美的代码**，这段代码顺利通过代码评审并合入到了主干。

可是，小E还是顺利完成了他的邪恶计划，问题出在哪里呢？完美的代码意味着 **完美的程序** 吗？

**说明：**

- 让程序发生段错误可以获得 Flag 1
- 拿到 shell 或执行命令 `cat ./flag2.txt` 可以获得 Flag 2

### 提示

- 本题的技术原理可参考 https://github.com/rust-lang/rust/issues/131813

除此之外，还有如下两个和 Flag 直接相关的提示：

- Flag 1：如果不想看技术原理，或许可以直接手玩一下？
- Flag 2：调试一下 Flag 1 的崩溃，或许可以想办法做到任意内存读写？在这之后，堆上的虚表指针是不是有一些神秘作用呢？

### 解答